import {
  autoGeneratedHashKey,
  table,
  attribute,
} from '@aws/dynamodb-data-mapper-annotations'
import { AttributePath, FunctionExpression } from '@aws/dynamodb-expressions'
import { embed, QueryOptions } from '@aws/dynamodb-data-mapper'
import { mapper, BaseModel } from '@360mediadirect/modeler'
import { User } from '../../../../common/interfaces/User'
import createError from 'http-errors'
import log from '@360mediadirect/log'
import { embassy, issuer, getSigningKeyId } from '../lib/authorizer'
import { UserClientModel } from './UserClientModel'
import { OrganizationModel } from './OrganizationModel'
import { unwrapNumbers } from '@360mediadirect/modeler/dist/ddb'
import { merge } from 'lodash'
import { Schema } from '@aws/dynamodb-data-marshaller'
import { DEFAULTS, AUTH_ERROR_CODES } from '../../../../common/constants'

export const ddbSchemaUser: Schema = {
  id: { type: 'String' },
  createdAt: { type: 'Number' },
  updatedAt: { type: 'Number' },
  deletedAt: { type: 'Number' },
  deletedReason: { type: 'String' },
  email: { type: 'String' },
  dob: { type: 'String' },
  firstName: { type: 'String' },
  lastName: { type: 'String' },
  clients: {
    type: 'List',
    memberType: {
      type: 'Document',
      members: {
        clientId: { type: 'String' },
        disabledAt: { type: 'Number' },
        description: { type: 'String' },
        lastUsedAt: { type: 'Number' },
        lastEnabledAt: { type: 'Number' },
      },
    },
  },
  idTokenMinIat: { type: 'Number' },
  source: { type: 'String' },
  subSource: { type: 'String' },
  domainScopes: { type: 'Any' },
  bannedAt: { type: 'Number' },
  lastLoginAt: { type: 'Number' },
  ipAddress: { type: 'String' },
  organizationId: { type: 'String' },
}

/**
 * The number of seconds for which a refresh token should stay valid after
 * being issued.
 */
const REFRESH_DURATION = process.env.REFRESH_DURATION
  ? +process.env.REFRESH_DURATION
  : DEFAULTS.REFRESH_DURATION

/**
 * The maximum number of clients a user can handle enabled at once time.
 */
const MAX_ENABLED_CLIENTS = process.env.MAX_ENABLED_CLIENTS
  ? +process.env.MAX_ENABLED_CLIENTS
  : DEFAULTS.MAX_ENABLED_CLIENTS

/**
 * The number of seconds that must pass before a disabled client can be
 * re-enabled, or an enabled client can be automatically disabled by another
 * authentication attempt.
 */
const MIN_CLIENT_TURNOVER_SECS = process.env.MIN_CLIENT_TURNOVER_SECS
  ? +process.env.MIN_CLIENT_TURNOVER_SECS
  : DEFAULTS.MIN_CLIENT_TURNOVER_SECS

const IGNORE_MAX_CLIENTS_DOMAIN = process.env.IGNORE_MAX_CLIENTS_DOMAIN
  ? process.env.IGNORE_MAX_CLIENTS_DOMAIN
  : DEFAULTS.IGNORE_MAX_CLIENTS_DOMAIN

export interface LoginClient {
  clientId: string
  description?: string
}

@table(process.env.USER_TABLE_NAME)
export class UserModel extends BaseModel implements User {
  @autoGeneratedHashKey() id: string
  @attribute() email: string
  @attribute() firstName?: string
  @attribute() lastName?: string
  @attribute() dob?: string
  @attribute({ defaultProvider: () => 0 })
  idTokenMinIat: number
  @attribute()
  source: 'bperx' | 'internal'
  @attribute() subSource: string
  @attribute({ memberType: embed(UserClientModel) })
  clients: UserClientModel[]
  @attribute() domainScopes?: Record<string, string[]>
  @attribute({ defaultProvider: () => Date.now() })
  createdAt: number
  @attribute({ defaultProvider: () => Date.now() })
  updatedAt: number
  @attribute() deletedAt: number
  @attribute() bannedAt?: number
  @attribute() lastLoginAt?: number
  @attribute() lastEmailStatus?: 'opened' | 'bounced' | 'spam'
  @attribute() lastEmailStatusChangedAt: number
  @attribute() ipAddress?: string
  @attribute() organizationId?: string
  @attribute() softBounceCount?: number
  @attribute() hasAtLeastOneDelivery?: boolean
  softBounceIncrement?: boolean

  private mergedDomainScopes: Record<string, string[]>
  private organization: OrganizationModel

  /**
   * Generates a new refresh token for this user. Refresh tokens have an
   * extremely long duration and are valid only for requesting a new, shorter
   * duration access token. They can be invalidated after being issued by
   * updating the user's `idTokenMinIat` property to a date after the refresh
   * token was issued.
   * @param opts An optional options object to customize the refresh token
   * @param opts.noEntitlements If true, access tokens created from this refresh
   *  token will not get the default entitlements|getEntitlements permission
   * @returns A refresh token in JWT format
   */
  async createRefreshToken(): Promise<string> {
    const token = embassy.createToken({
      sub: this.id,
      email: this.email,
    })
    // Refresh tokens last much longer, but the audience is only the service that
    // created it so it cannot be used for normal API calls
    const signed: string = await token.sign(getSigningKeyId(), {
      expiresInSecs: REFRESH_DURATION,
      audience: issuer,
    })
    return signed
  }

  /**
   * Logs a user in, updating their record with a new `lastLoginAt` and saving
   * the record back to the database. Once this is successful, an access token
   * is generated and returned. Note that this function _does not_ validate
   * or verify credentials. It is assumed that the code completes this step
   * before this function is called.
   * @param method the login mechanism being used, such as "magic" or "refresh".
   * This is used only for logging purposes.
   * @param client The client that's responsible for this login
   * @param domainScopes An optional map of domains to scopes that should be
   * granted on this user's accessToken, beyond those defined in their user
   * record.
   * @returns An access token in JWT format
   */
  async login(opts: {
    method: string
    client: LoginClient
    orgType?: 'publisher' | 'auditor'
    ip?: string
    domainScopes?: Record<string, string[]>
    requiredScopes?: string[]
  }): Promise<string> {
    if (this.bannedAt) {
      log.info('Banned user attempted sign-in', {
        user: this,
        method: opts.method,
      })
      throw createError(401, 'Sorry, this account has been disabled.', {
        errorCode: AUTH_ERROR_CODES.ACCOUNT_DISABLED,
      })
    }
    this.registerClient(opts.client)
    this.lastLoginAt = Date.now()
    if (opts.ip) this.ipAddress = opts.ip
    await this.save()
    const accessToken = await this.createAccessToken(
      opts.client.clientId,
      opts.domainScopes,
      opts.requiredScopes,
    )
    log.info('User logged in', { user: this, method: opts.method })
    return accessToken
  }

  /**
   * Merges the user's domainScopes with their org's domainScopes (if
   * applicable) and returns the result, also caching it on this UserModel
   * instance so that it can be retrieved without future DB lookups later.
   * @returns This user's full list of domain scopes, including those that
   * are granted by their org membership
   */
  private async getAllDomainScopes(): Promise<Record<string, string[]>> {
    if (!this.mergedDomainScopes) {
      this.mergedDomainScopes = {}
      const orgScopes = (await this.getOrganization())?.domainScopes
      merge(this.mergedDomainScopes, orgScopes || {}, this.domainScopes || {})
    }
    return this.mergedDomainScopes
  }

  /**
   * Get this user's Organization record, if they belong to an organization.
   * This function stores the data after it's fetched once, so successive
   * calls are inexpensive.
   * @returns The Organization record associated with this user
   */
  public async getOrganization(): Promise<OrganizationModel> {
    if (!this.organizationId) return undefined
    if (!this.organization) {
      this.organization = await OrganizationModel.get({
        id: this.organizationId,
      })
    }
    return this.organization
  }

  /**
   * Creates an access token JWT for this user. The public should call
   * {@link UserModel#login} instead.
   * @param clientId An arbitrary string uniquely representing the client for
   * which the access token is being issued.
   * @param domainScopes An optional map of domains to scopes that should be
   * granted on this user's accessToken, beyond those defined in their user
   * record.
   * @param requiredScopes An optional list of scopes that are required for
   * this login to succeed, in the format domain|scopeName
   * @returns An access token in JWT format
   */
  private async createAccessToken(
    clientId: string,
    domainScopes?: Record<string, string[]>,
    requiredScopes?: string[],
  ): Promise<string> {
    const org = await this.getOrganization()
    const token = embassy.createToken({
      sub: this.id,
      email: this.email,
      fna: this.firstName,
      lna: this.lastName,
      cli: clientId,
      ...(this.organizationId && { oid: this.organizationId }),
    })
    await token.grantScopes(await this.getAllDomainScopes())
    if (domainScopes) await token.grantScopes(domainScopes)
    if (requiredScopes && !(await token.hasScopes(requiredScopes))) {
      throw createError(
        403,
        "Sorry, you don't have permission to log in here",
        { errorCode: 'MISSING_REQUIRED_SCOPES' },
      )
    }
    const signed: string = await token.sign(getSigningKeyId())
    return signed
  }

  /**
   * Finds the least-recently-used active client in the clients array, and
   * disables it by setting its `disabled_at` timestamp.
   * @throws 401 with TOO_MANY_CLIENTS errorCode if the least-recently-used
   * client was last enabled within the MIN_CLIENT_TURNOVER_SECS threshold
   */
  private disableLastClient(): void {
    const activeClients = this.clients.filter((c) => !c.disabledAt)
    activeClients.sort((a, b) => b.lastUsedAt - a.lastUsedAt)
    const lastClient = activeClients.pop()
    const earliestLegal =
      lastClient.lastEnabledAt + MIN_CLIENT_TURNOVER_SECS * 1000
    if (Date.now() < earliestLegal) {
      log.error('TOO_MANY_CLIENTS', {
        id: this.id,
        email: this.email,
        clients: this.clients,
      })
      throw createError(
        401,
        `You've reached the ${MAX_ENABLED_CLIENTS}-device maximum limit on your account too quickly. Please try again later.`,
        { errorCode: AUTH_ERROR_CODES.TOO_MANY_CLIENTS },
      )
    }
    lastClient.disabledAt = Date.now()
  }

  /**
   * Registers and enables/refreshes a device in the user's account. This
   * function validates that the user is allowed to register this device by
   * checking a variety of factors related to device count and recency of
   * registration dates. If registration is blocked for any reason, an HTTP 401
   * error will be thrown with an errorCode property consistent with the
   * OpenAPI spec documentation for the authentication endpoints.
   *
   * Note that this function will change the `devices` array within this model
   * instance, but does not save it back to the database. `save()` should
   * always be called sometime after this function completes.
   * @param loginClient The device information to be registered
   * @throws 401 if registration was blocked for any reason
   */
  private registerClient(loginClient: LoginClient): void {
    if (!this.clients) this.clients = []
    const client = Object.assign(new UserClientModel(), loginClient)
    const activeClients = this.clients.filter((d) => !d.disabledAt)
    let currentRecord = this.clients.find((c) => c.clientId === client.clientId)
    if (currentRecord && !currentRecord.disabledAt) {
      // The client being used is already registered and enabled
      currentRecord.lastUsedAt = Date.now()
      return undefined
    }
    if (
      activeClients.length >= MAX_ENABLED_CLIENTS &&
      !this.email?.includes(IGNORE_MAX_CLIENTS_DOMAIN)
    ) {
      // We already have the maximum number of clients registered
      // If this doesn't throw, we're good to add another client
      this.disableLastClient()
    }
    if (currentRecord && !this.email?.includes(IGNORE_MAX_CLIENTS_DOMAIN)) {
      // The client being used was previously disabled. Ensure turnover is legal
      const earliestLegal =
        currentRecord.disabledAt + MIN_CLIENT_TURNOVER_SECS * 1000
      if (Date.now() < earliestLegal) {
        throw createError(
          401,
          'Sorry, this client was disabled too recently to be used again. Please try again later.',
          { errorCode: AUTH_ERROR_CODES.CLIENT_RECENTLY_DISABLED },
        )
      }
      // Turnover is legal. Re-enable the client
      delete currentRecord.disabledAt
    } else {
      // This is a new client
      this.clients.push(client)
      currentRecord = client
    }
    currentRecord.lastEnabledAt = Date.now()
    currentRecord.lastUsedAt = Date.now()
  }

  /**
   * Creates a new UserModel from existing properties
   * @param obj The properties from which to create a new UserModel
   * @returns a new UserModel instance with properly embedded classes
   */
  public static from<T extends BaseModel>(obj: Partial<User>): T {
    const model = new this()
    const { clients, ...userData } = obj
    Object.assign(model, userData)
    if (clients?.length) {
      model.clients = clients.map((c) =>
        Object.assign(new UserClientModel(), c),
      )
    }
    return model as unknown as T
  }

  /**
   * Gets an array of active users in arbitrary order. "Active" is defined as
   * not having a truthy deletedAt value.
   * @param limit The number os records to retrieve
   * @param startKey The last user ID returned from the last set of results.
   *    This instructs this function to retrieve records starting from that
   *    key, exclusive of that record itself.
   * @returns An array of active users
   */
  public static async getActiveUsers(
    limit: number,
    startKey?: Record<string, any>,
  ) {
    const users = []
    const options: QueryOptions = {
      limit,
      filter: new FunctionExpression(
        'attribute_not_exists',
        new AttributePath('deletedAt'),
      ),
      ...(startKey && { startKey }),
    }
    for await (const user of mapper.scan(UserModel, options)) {
      users.push(unwrapNumbers(user))
    }
    return users
  }

  /**
   * Saves the user back to the database, generating any default or
   * auto-generated properties and adding them back to this user object
   * in-place.
   */
  public async save<T extends BaseModel>(): Promise<T> {
    if (this.email) this.email = this.email.trim().toLowerCase()
    return super.save()
  }
}
